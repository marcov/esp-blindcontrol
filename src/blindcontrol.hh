#ifndef __BLINDCONTROL_HH__
#define __BLINDCONTROL_HH__

#include "config.h"
#include <Timer.h>

#define max(A,B)  ((A) >= (B) ? (A) : (B))

static inline void timerCallback(void);

class BlindControl {

private:
    typedef enum {
        RELAY_UP   = GPIO_RL1,
        RELAY_DOWN = GPIO_RL2,
        RELAY_NONE = 0xFF,
    } relay_t;

    enum  {
        RELAY_STATE_MOVE = HIGH,
        RELAY_STATE_IDLE = LOW,
    };
    Timer moveTimer;
    int   tId;
    relay_t activeRelay;
    unsigned repeat;

    void startMoving(relay_t pin, unsigned long timeMs)
    {
        if ((activeRelay != RELAY_NONE) ||
            (digitalRead(RELAY_UP) != RELAY_STATE_IDLE) ||
            (digitalRead(RELAY_DOWN) != RELAY_STATE_IDLE)) {
            return;
        }

        repeat = 0;
        digitalWrite(pin, RELAY_STATE_MOVE);
        activeRelay = pin;

        tId = moveTimer.after(timeMs, timerCallback);
    }

    void stopMoving(void) {
        moveCtr++;
        if (repeat > 0) {
            repeat--;
            tId = moveTimer.after(UPDOWN_MIN_T_MS, timerCallback);
            return;
        }

        Serial.println("end move");
        digitalWrite(activeRelay, RELAY_STATE_IDLE);
        activeRelay = RELAY_NONE;
        lastMoved = 0;
    }

    int updown(bool up, unsigned ms) {
        auto tgtRelay = up ? RELAY_UP : RELAY_DOWN;

        if (ms < UPDOWN_MIN_T_MS || ms > UPDOWN_MAX_T_MS) {
            ms = UPDOWN_MIN_T_MS;
        }

        // repeat mode
        if (activeRelay == tgtRelay && ms == UPDOWN_MIN_T_MS) {
            repeat++;
            return 1;
        }

        // needs to be idle
        if (activeRelay != RELAY_NONE) {
            return -1;
        }

        startMoving(tgtRelay, ms);
        Serial.println("going up");
        return 0;
    }


public:
    unsigned uptime;
    unsigned lastMoved;
    unsigned moveCtr;
    static constexpr unsigned TOP_T_MS        = BLIND_BOTTOM_2_TOP_MS;
    static constexpr unsigned BOTTOM_T_MS     = BLIND_TOP_2_BOTTOM_MS;
    static constexpr unsigned UPDOWN_MIN_T_MS = 1 * 1000;
    static constexpr unsigned UPDOWN_MAX_T_MS = (TOP_T_MS >= BOTTOM_T_MS) ? TOP_T_MS : BOTTOM_T_MS;

    void updateCounters() {
        uptime++;
        lastMoved++;
    }

    void init() {
        activeRelay = RELAY_NONE;
        digitalWrite(RELAY_UP, RELAY_STATE_IDLE);
        digitalWrite(RELAY_DOWN, RELAY_STATE_IDLE);

        pinMode(RELAY_UP, OUTPUT);
        pinMode(RELAY_DOWN, OUTPUT);
        tId = -1;
        repeat = 0;
    }

    int up(unsigned ms) {
        return updown(true, ms);
    }

    int down(unsigned ms) {
        return updown(false, ms);
    }

    int top() {
        return up(TOP_T_MS);
    }

    int bottom() {
        return down(BOTTOM_T_MS);
    }

    void loop() {
        moveTimer.update();
    }

    bool moving() {
        return (activeRelay != RELAY_NONE);
    }

    int stop(bool stopByTimer) {
        // stop command not generated by timer callback => need to stop timer
        if (!stopByTimer &&  tId != -1) {
            moveTimer.stop(tId);
            repeat = 0;
        }

        tId = -1;

        // stopping by timer callback OR it is moving => stop moving
        if (stopByTimer || moving()) {
            stopMoving();
        }

        return 0;
    }
};

extern BlindControl blindCtl;

static inline void timerCallback(void) {
    blindCtl.stop(true);
}


#endif /* #ifndef __BLINDCONTROL_HH__ */
